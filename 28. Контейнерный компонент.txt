



	Функциональный компонент - получает props отрисовывает UI.
	PS - При прокидывании по props нам нужно прокидывать как можно меньше, чтобы компоненты не содержали лишнего.


	Контейнерный компонент - компонент, который имеет доступ к store и dispatch. Который прокидывает callback-и к функц. компонентам.
	Чтобы callback-и вызывались там и тем самым ограничить доступ функциональных компонент к store и dispatch.
	Контейнерному компоненту разрешается иметь данные и логику из store(dispatch, state...).
	Обязанностями контейнерного компонента являются обеспечение функциональных(презентационных) компонентов данными и callback-ами.


	*** В данный момент наши компоненты содержать больше информации из store чем нужно, например dispatch, actionCreator...
	Это нарушает принципы функц. программирования, также это небезопасно. Мы можем прокинуть dispatch до какого-либо контейнерного компонента, далее прокинуть callback-и в функциональные компоненты,
	которые вызовут dispatch при вызове. Значит мы можем изолировать каждый презентационный комопнент конетйнерным компонентом, который ограничит презентационную от информации из BLL.
	И будет обеспечивать данными и логикой этот презентационный компонент через props.


	После этих действий в наших презентационных компонентах не будут лишние функции, которые выполняются при взаимодейстии с UI. 
	Теперь наши презентационные компоненты будут содершать и возврощать только jsx тег и ничего лишнего. А при всаимодействии будут вызваны callback-и из props.

	Т.е. контейнерный компонент - компонент родитель какого-либо презентационного компонента. Который изолирует презентационный компонент от доступа к бизнес логике(store, state, dispatch)
	Задача контейнерного компонента. Содержать презентационный компонент и снабжать его. 



	Таким образом, когда у нас есть право доводить данные BLL до контейнерных компонентов, мы можем перенести весь store в контейнерные компоненты, чтобы было удобно работать с store




	Данный подход дает нам чистые презент. компоненты, у них есть возможность повторно использоваться в другом месте, даже в других проектах.
	И полностью независимы от внешних данных.
	Также ограничивает внешний мир от BLL. 