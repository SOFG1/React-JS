
			FLUX - Архитектура в React

	FLUX - архитектура отображения данных в UI. Главным правилом является, то что содержимое UI никак не может поменяться сам по себе.
	
	Содержимое UI, только отрисовывается по состоянию state. А при взаимодействии пользователя идет запрос в state, при надобности меняется state и происходит ререндеринг.






				Передача данных из UI в State(BLL)

	Для того чтобы менять данные в state(BLL), мы должны иметь функцию в state, которая поменяет определенные данные.

	Эту функцию мы должны закинуть в UI пропсами и вызывать уже в UI при надобности, также можем задавать аргументы в UI, которые задействуют в state. Т.к. функция выполнится в state.



	Пример на добавлении поста:


	// State /////

	let addPost = (text) => {
					state.posts.push({
							   id: state.posts.length + 1,
							   postText: text
							  })
					render()
				 }

	let state = {
			posts: [...posts],
			addPost: addPost
		     }
	// State /////

	///////////////////////////////////////////////////////////////////

	// Posts.jsx //////

	import {useRef} from 'react'
	let postText = useRef();


	let addPost = ()=> props.addPost(postText.current.value)    

	<textarea ref={postText}></textarea>
	<button onClick={addPost}>Add post</button>


	// Posts.jsx //////

	Далее нам нужно перерисовать изменения, для этого действия в index.js(ReactDOM.render()) мы добавляем в функцию. И вызываем после добавления поста.

	!НО мы не имеем права импортировать эту функцию в state.js. Потому что нам запрещено экспортировать файлы туда, откуда мы импортировали что-то - будет циклическая зависимость.

	Далее чтобы предотвратить циклическую зависимость, мы должны добавить функцию ререндера в отдельный файл и экспортировать и в index.js и в state.js




	В итоге мы имеем в state функцию, которая добавляет пост. Мы прокидываем ее в UI через пропсы и вызываем ее с нужными параметрами.

	Этот процесс представляет из себя круговорот: ОТРИСОВКА ДАННЫХ ИЗ STATE(REDUX) --> ВЗАИМОДЕЙСТВИЕ ПОЛЬЗОВАТЕЛЯ В UI --> ЗАПРОС НА ИЗМЕНЕНИЕ В STATE(REDUX) --> ПОВТОРНАЯ ОТРИСОВКА ДАННЫХ ИЗ STATE(REDUX)

	Архитектура данного процесса называется - FLUX.

	Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. 
	Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой.
	Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении[1].





	Один главный принцип FLUX архитектуры - то что, UI меняется, только когда появляются изменения в state. 

	Даже например изменение в инпуте является нарушением. Потому что, state не меняется, а UI меняется.

	Т.е. даже изменения в input-е в UI должны исходить от state, чтобы не нарушать архитектуру FLUX. Значит каждое изменение в инпуте должно переходить в state,а потом заново отрисоваться из него.

		
		
			Пример: 

	
		let changeTextArea = () => {							// Создаем функцию внутри компонента, которая выполняется при onChange текста
					     props.changeText(textArea.current.value);		// Выполняем функцию из state, которая меняет значение текста на принимаемое значение и заново рендерит UI.
						}




		<textarea onChange={changeTextArea} value={props.text} ref={textArea}/>	 	// Наша textarea которая стандартно работает, соблюдая правила FLUX архитектуры.


		PS - В примере выше мы соблюдаем принципы FLUX архитектуры. И происходит круговорот.















