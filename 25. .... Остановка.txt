


		Теперь с применением reducer-ов. У нас есть следующая архитектура в UI и в BLL:

	
	1) JSX компоненты в UI - Только отображают содержимое state, которые приходят через props. При взаимодействии вызывает функции в своем reducer-e, которые находятся в BLL.

	Эти компоненты полностью соответствуют принципу функционального программирования - они отображают UI в зависимости только от приходящих props-ов. Независимы глобально.



	

	
	2) Store и State. State - обьект, который содержит все данные, которые будут переданы через props и отображены в приложении. 

	PS - state не передается по props, передается store, который имеет метод getstate()
	
	Store - ООП обьект, который является интерфейсом управления state-ом. Содержит сам state и методы управления.(dispatch, subscribe, getState...). Передается через props.

	




	3) Reducer - js файл в BLL, который отвечает за бизнес логику каждого компонента в BLL. Т.к. функциональные компоненты только отображают содержимое props и не имеют права менть state.
	
	Содержимое reducer :
			
			1. Логика, которая будет выполнена при вызове dispatch()

			2. actionCreator - функция, которая создает обьект action в UI, который будет применен в dispatch и в логике самого reducer-a.

	Логика reducer-ов могла быть выполнена в dispatch(), но т.к. в приложении может быть тысячи компонентов с разной логикой мы распределяем(переносим) логику в reducer-ы.
	Каждый reducer() выполняется в dispatch(), далее приложение ререндерится.






	

	