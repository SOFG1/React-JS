



	Контекст - позволяет проносить информацию от самых верхних компонент нашего дерева до самых нижних, не передавая через каждую ступень по пропсам.
	

	*** В данный момент store  мы прокидываем от верхних компонент, к нижним через пропсы. Но средние компоненты не нуждаются в store... 
	Тем самым мы делаем наш код громоздким, добавляя store в props каждого компонента.


	Т.е. мы можем добавить данные из родительского компонента в его контекст и у его дочерних компонентов будет доступ к контексту родительского компонента. 
	И они могут получить данные напрямую из контекста (не через пропс). 
	PS - контекст будет доступен только дочерним, у компонентов выше уровнем или не имеющих вложенность в эту не будет доступа к контексту.

	НО контекст не замена props. Контекст предназначен для предоставления доступа глобальных вещей(например store, dispatch, тема приложения, язык...).
	Если мы все закинем в контекст, мы загрязним глобальную область видимости, что приведет к багам.



		Пример применения контекста store:

		// StoreContext.js ////////////////////////////////////////////

		const StoreContext = React.createContext(null)				// Создаем пустой контекст с названием StoreContext

		export default StoreContext						// Экспортируем
		


		// StoreContext.js ////////////////////////////////////////////

		
		
		// index.js ////////////////////////////////////////////
		import React from 'react'
		import StoreContext from 'StoreContext'					// Импортируем в компонент дочерним компонентам которого будет доступен контекст.

		let render = () => {
		    ReactDOM.render(
		        <React.StrictMode>
		            <BrowserRouter>
		                <StoreContext.Provider value={store}>			// <StoreContext.Proveider value={store}> Родитель обертка, дочерним элементам будет доступен контекст. Значением будет аттрибут value. т.е. store
		                    <App />						// Помещаем <App/>
		                </StoreContext.Provider>
		            </BrowserRouter>
		        </React.StrictMode>,
		        document.getElementById('root')
		    );
		}
		render();
		// index.js ////////////////////////////////////////////


		// ComponentContainer.jsx //////////////////////////////////////////// Дочерний элемент, которому будет доступен контекст

		import StoreContext from '../../../StoreContext';
		import PresentComponent from './PresentComponent';

		const ComponentContainer = (props)=> {				// Наш контейнерный компонент, берет store из контекста и возвращает презент. компонент с полученными данными.
							  <StoreContext.Consumer>{ (store)=> {<PresentComponent data={store.getState().data} />} }</StoreContext.Consumer>
							}

		// ComponentContainer.jsx /////////////////////////////////////////////////////////////////









				React-Redux


		В примере выше мы используем Context.Provider и Context.Consumer Они состоят из дополнительного тега, который загружает код.
		Мы можем вынести например Context.Provider в отдельный компонент, который будет принимать компонент, возвращать и добавлять контекст по пути. т.е. инкапсулировать.
		Также есть библиотека React-Redux, в которой уже есть данный метод.

		
 

















